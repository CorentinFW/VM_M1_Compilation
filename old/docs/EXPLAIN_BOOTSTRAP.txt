â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
QU'EST-CE QUE LE BOOTSTRAP ? 
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DÃ‰FINITION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Le "bootstrap" (ou "bootstrapping") est le processus par lequel
un systÃ¨me informatique se construit LUI-MÃŠME.

C'est comme "se soulever par ses propres lacets de chaussures"
(d'oÃ¹ le nom "bootstrap" en anglais).

En compilation, cela signifie:
â†’ Un compilateur qui se compile LUI-MÃŠME
â†’ CrÃ©er un systÃ¨me auto-suffisant

ANALOGIE SIMPLE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Imaginez que vous voulez construire une maison:

SANS BOOTSTRAP:
  Niveau 0: Vous avez des outils (Common Lisp)
  Niveau 1: Vous construisez la maison avec ces outils
  â†’ La maison dÃ©pend TOUJOURS des outils externes

AVEC BOOTSTRAP:
  Niveau 0: Vous avez des outils basiques (Common Lisp)
  Niveau 1: Vous construisez une usine d'outils (VM native)
  Niveau 2: L'usine fabrique ses propres outils (VM compilÃ©e)
  Niveau 3: Les nouveaux outils construisent une meilleure usine
  Niveau 4: La nouvelle usine peut SE reconstruire ELLE-MÃŠME
  â†’ Le systÃ¨me est AUTONOME, ne dÃ©pend plus de l'extÃ©rieur!

POURQUOI C'EST IMPORTANT ?
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. INDÃ‰PENDANCE
   Le systÃ¨me ne dÃ©pend plus d'un langage externe
   
2. CONFIANCE
   Le compilateur compile son propre code
   â†’ Si Ã§a marche, on sait que le compilateur est correct!
   
3. OPTIMISATION
   Le compilateur peut s'optimiser lui-mÃªme
   
4. PORTABILITÃ‰
   Une fois bootstrappÃ©, le systÃ¨me est auto-suffisant

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
LES NIVEAUX DE BOOTSTRAP - EXPLICATION DÃ‰TAILLÃ‰E
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

NIVEAU 0 : SYSTÃˆME HÃ”TE (Ce qu'on a au dÃ©part)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Common Lisp (CLISP)       â”‚  â† Langage existant
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€         â”‚
â”‚   - DÃ©jÃ  installÃ©           â”‚
â”‚   - InterprÃ¨te natif        â”‚
â”‚   - Outils de dÃ©veloppement â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Exemple:
  (defun double (x) (* x 2))
  (double 5)
  â†’ 10

Ã‰tat: Code LISP exÃ©cutÃ© DIRECTEMENT par CLISP
Fichiers: compiler.lisp, vm.lisp, loader.lisp (en Common Lisp)


NIVEAU 1 : VM NATIVE (Ce qu'on a construit)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Common Lisp               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚ exÃ©cute
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   VM Native (vm.lisp)       â”‚  â† Notre machine virtuelle
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€         â”‚
â”‚   - Ã‰crite en Common Lisp   â”‚
â”‚   - InterprÃ¨te du bytecode  â”‚
â”‚   - 43 opcodes              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Exemple:
  Code LISP: (+ 2 3)
  
  Compilation â†’ Bytecode ASM:
    PUSH 2
    PUSH 3
    ADD
    HALT
  
  ExÃ©cution â†’ VM native l'interprÃ¨te â†’ 5

Ã‰tat: VM Ã©crite en CL, exÃ©cute du bytecode
DÃ©pendance: CLISP (pour faire tourner la VM)
Fichiers: compiler.lisp (CL) â†’ bytecode â†’ vm.lisp (CL)


NIVEAU 2 : VM COMPILÃ‰E âœ… [IMPLÃ‰MENTÃ‰!]
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Common Lisp               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚ exÃ©cute
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   VM Native (vm.lisp)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚ exÃ©cute
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   VM CompilÃ©e (bytecode)    â”‚  â† Une VM Ã©crite en LISP pur
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€         â”‚     et compilÃ©e en bytecode!
â”‚   - Code LISP compilÃ©       â”‚
â”‚   - Simule une VM           â”‚
â”‚   - Fait des calculs        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Exemple (ce qu'on a dÃ©montrÃ©):
  1. Ã‰crire une mini-VM en LISP pur:
     (defun vm-push (vm val)
       (cons (cons val (car vm)) (cdr vm)))
  
  2. Compiler ce code â†’ bytecode
  
  3. Charger sur VM native
  
  4. La VM compilÃ©e calcule (5 + 3) â†’ 8
  
  C'est comme une poupÃ©e russe: 
  VMâ‚ exÃ©cute VMâ‚‚ qui fait des calculs!

Ã‰tat: VM Ã©crite en LISP, compilÃ©e, tourne sur VM native
DÃ©pendance: VM native (niveau 1)
Fichiers: vm-bootstrap.lisp (LISP pur) â†’ bytecode â†’ vm.lisp (CL)

ACCOMPLISSEMENT: âœ… FONCTIONNEL (7/8 tests)
  â†’ Une VM compilÃ©e exÃ©cute des programmes!


NIVEAU 3 : LOADER COMPILÃ‰ âŒ [NON IMPLÃ‰MENTÃ‰]
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Common Lisp               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚ exÃ©cute
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   VM Native (vm.lisp)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚ exÃ©cute
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   VM CompilÃ©e               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚ exÃ©cute
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Loader CompilÃ©            â”‚  â† Parser ASM Ã©crit en LISP,
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€         â”‚     compilÃ©, qui tourne sur
â”‚   - Parse ASM en LISP pur   â”‚     la VM compilÃ©e!
â”‚   - RÃ©sout les labels       â”‚
â”‚   - Produit du bytecode     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Objectif: Ã‰crire un mini-loader en LISP pur (sans defstruct,
         sans hash-tables), le compiler, et l'exÃ©cuter.

Exemple thÃ©orique:
  1. Ã‰crire mini-loader.lisp en LISP pur
     (defun parse-asm (lines)
       (map-lines lines parse-line))
  
  2. Compiler mini-loader.lisp â†’ bytecode
  
  3. Charger sur VM niveau 2
  
  4. Le loader compilÃ© parse un fichier ASM
  
  5. Produit du bytecode exÃ©cutable

Ã‰tat: NON FAIT
DifficultÃ©: MOYENNE
Avantage: Le loader peut charger du code sans dÃ©pendre de CL


NIVEAU 4 : COMPILER COMPILÃ‰ âŒ [NON IMPLÃ‰MENTÃ‰]
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Common Lisp               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚ exÃ©cute
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   VM Native (vm.lisp)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚ exÃ©cute
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   VM CompilÃ©e               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚ exÃ©cute
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Loader CompilÃ©            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚ charge
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Compiler CompilÃ©          â”‚  â† Compilateur LISPâ†’ASM
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€         â”‚     Ã©crit en LISP pur,
â”‚   - Parse S-expressions     â”‚     compilÃ©, qui tourne
â”‚   - GÃ©nÃ¨re ASM              â”‚     sur la VM compilÃ©e!
â”‚   - En LISP pur             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Objectif: Ã‰crire un mini-compiler en LISP pur, le compiler,
         et l'exÃ©cuter sur la VM compilÃ©e.

Exemple thÃ©orique:
  1. Ã‰crire mini-compiler.lisp en LISP pur
     (defun compile-expr (expr)
       (cond
         ((numberp expr) (list 'PUSH expr))
         ((eq (car expr) '+) (compile-add expr))
         ...))
  
  2. Compiler mini-compiler.lisp â†’ bytecode
  
  3. Charger sur VM niveau 2 (via loader niveau 3)
  
  4. Le compiler compilÃ© compile du code LISP:
     Input: (+ 2 3)
     Output: PUSH 2 / PUSH 3 / ADD / HALT

Ã‰tat: NON FAIT
DifficultÃ©: TRÃˆS Ã‰LEVÃ‰E
Avantage: Le compilateur peut compiler du code
         sans dÃ©pendre de Common Lisp!


NIVEAU 5 : AUTO-HÃ‰BERGEMENT (SELF-HOSTING) âŒ [OBJECTIF FINAL]
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Common Lisp               â”‚  â† UtilisÃ© UNE FOIS au dÃ©part
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚ bootstrap initial
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SYSTÃˆME AUTO-HÃ‰BERGÃ‰                     â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚
â”‚                                                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                         â”‚
â”‚   â”‚ Compiler     â”‚â”€â”€â”€â”€â”                                    â”‚
â”‚   â”‚ (bytecode)   â”‚    â”‚                                    â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚ se compile                        â”‚
â”‚          â–²            â”‚ lui-mÃªme                           â”‚
â”‚          â”‚            â–¼                                    â”‚
â”‚          â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                             â”‚
â”‚          â””â”€â”€â”€â”€â”‚ Compiler     â”‚                             â”‚
â”‚               â”‚ (source)     â”‚                             â”‚
â”‚               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                             â”‚
â”‚                                                             â”‚
â”‚   Le compilateur peut SE COMPILER LUI-MÃŠME!                â”‚
â”‚   Il ne dÃ©pend PLUS de Common Lisp!                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

C'est le SAINT GRAAL du bootstrap!

Objectif: Le mini-compiler (en LISP pur) se compile lui-mÃªme
         et produit un bytecode identique!

Processus:
  1. Version 1: mini-compiler.lisp (source)
     CompilÃ© par compiler.lisp (Common Lisp)
     â†’ mini-compiler v1 (bytecode)
  
  2. Version 2: mini-compiler.lisp (source)
     CompilÃ© par mini-compiler v1 (bytecode)
     â†’ mini-compiler v2 (bytecode)
  
  3. VÃ©rification: v1 == v2 ?
     Si OUI â†’ AUTO-HÃ‰BERGEMENT RÃ‰USSI! ğŸ‰
     Le systÃ¨me est AUTONOME!

Ã‰tat: NON FAIT
DifficultÃ©: MAXIMALE
Avantage: INDÃ‰PENDANCE TOTALE
         Le systÃ¨me peut Ã©voluer sans Common Lisp!

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
COMPARAISON DES NIVEAUX
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Niveauâ”‚ Quoi?              â”‚ Ã‰crit en  â”‚ Tourne sur    â”‚ DÃ©pend de
â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  0   â”‚ Common Lisp        â”‚ C/ASM     â”‚ CPU           â”‚ OS
  1   â”‚ VM Native          â”‚ CL        â”‚ CLISP         â”‚ CLISP
  2   â”‚ VM CompilÃ©e     âœ… â”‚ LISP pur  â”‚ VM Native     â”‚ VMâ‚
  3   â”‚ Loader CompilÃ©  âŒ â”‚ LISP pur  â”‚ VM CompilÃ©e   â”‚ VMâ‚‚
  4   â”‚ Compiler CompilÃ©âŒ â”‚ LISP pur  â”‚ VM CompilÃ©e   â”‚ VMâ‚‚+Loadâ‚ƒ
  5   â”‚ Self-hosting    âŒ â”‚ LISP pur  â”‚ Lui-mÃªme!     â”‚ Lui-mÃªme!

âœ… = ImplÃ©mentÃ© et fonctionnel
âŒ = Non implÃ©mentÃ©

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EXEMPLES CONCRETS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

NIVEAU 1 - Ce qu'on utilise normalement:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
$ clisp
> (load "compiler.lisp")
> (compile-and-run '(+ 2 3))
5

Ici: CLISP exÃ©cute compiler.lisp qui produit du bytecode
     que vm.lisp (en CL) exÃ©cute.


NIVEAU 2 - Ce qu'on a dÃ©montrÃ©:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Code LISP pur (mini-VM):
  (defun vm-push (vm v) 
    (cons (cons v (car vm)) (cdr vm)))
  
  (defun vm-add (vm)
    (let ((b (car (car vm))))
      (let ((a (car (cdr (car vm)))))
        (cons (cons (+ a b) (cdr (cdr (car vm)))) 
              (cdr vm)))))

Compilation â†’ bytecode:
  ALLOC 1
  PUSH 0
  CALL FUNC_VM-PUSH
  ...

ExÃ©cution sur VM native â†’ RÃ©sultat: 8

C'est une VM dans une VM! (Inception!)


NIVEAU 3 - Objectif suivant:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
mini-loader.lisp (LISP pur):
  (defun parse-line (line)
    (if (null line)
        0
        (let ((op (car line)))
          (cond
            ((eq op 'PUSH) (cons 2 (parse-operand (cdr line))))
            ((eq op 'ADD) (cons 10 0))
            ...))))

â†’ Compiler ce code
â†’ Le loader compilÃ© peut charger du code!


NIVEAU 4 & 5 - Objectif ultime:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
mini-compiler.lisp compile mini-compiler.lisp

  Input: (defun compile-expr (expr) ...)
  Output: PUSH ... / CALL ... / RET / ...
  
  Ce bytecode produit EXACTEMENT le mÃªme compilateur!
  â†’ Le serpent se mord la queue! ğŸ

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
POURQUOI C'EST DIFFICILE ?
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

NIVEAU 2: â­â­ MOYENNE
  - Utiliser seulement listes (cons/car/cdr)
  - Pas de defstruct, pas de hash-tables
  - Tout en fonctions pures
  â†’ FAIT! âœ…

NIVEAU 3: â­â­â­ MOYENNE-Ã‰LEVÃ‰E
  - Parser ASM avec seulement des listes
  - RÃ©soudre les labels sans hash-table
  - GÃ©rer les symboles
  
NIVEAU 4: â­â­â­â­ TRÃˆS Ã‰LEVÃ‰E
  - Parser S-expressions en LISP pur
  - Toute la logique de compilation
  - GÃ©nÃ©ration d'ASM
  - Gestion de l'environnement sans hash-tables
  
NIVEAU 5: â­â­â­â­â­ MAXIMALE
  - Le code du compiler doit Ãªtre assez simple
    pour Ãªtre compilable par lui-mÃªme
  - VÃ©rifier que v1 == v2 (bit Ã  bit)
  - Debugging extrÃªmement complexe
  - ProblÃ¨me de l'Å“uf et la poule!

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EXEMPLES RÃ‰ELS DE BOOTSTRAP
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

GCC (GNU C Compiler):
  - Ã‰crit en C
  - Se compile lui-mÃªme
  - Niveau 5 atteint!

Rust:
  - Anciennement compilÃ© par OCaml
  - Maintenant Ã©crit en Rust
  - Se compile lui-mÃªme (rustc)
  - Niveau 5 atteint!

PyPy (Python):
  - InterprÃ¨te Python Ã©crit en Python
  - Niveau 5 atteint!

Notre projet:
  - Compilateur LISP Ã©crit en Common Lisp âœ…
  - VM qui peut exÃ©cuter VM compilÃ©e âœ…
  - Niveau 2 atteint! âœ…
  - Niveaux 3-5 restent Ã  faire âŒ

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
RÃ‰SUMÃ‰ SIMPLE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

BOOTSTRAP = Un systÃ¨me qui se construit lui-mÃªme

Progression:
  Niveau 0: Common Lisp (point de dÃ©part)
  Niveau 1: VM en Common Lisp âœ…
  Niveau 2: VM compilÃ©e sur VM âœ… [ON EST ICI!]
  Niveau 3: Loader compilÃ© âŒ
  Niveau 4: Compiler compilÃ© âŒ
  Niveau 5: Compiler qui se compile lui-mÃªme âŒ [OBJECTIF FINAL]

Avantages du bootstrap complet:
  âœ“ IndÃ©pendance (ne dÃ©pend plus de CL)
  âœ“ Confiance (le compiler se valide lui-mÃªme)
  âœ“ PortabilitÃ© (systÃ¨me auto-suffisant)
  âœ“ Optimisation (peut s'amÃ©liorer lui-mÃªme)

Notre accomplissement actuel:
  â†’ Niveau 2 fonctionnel = EXCELLENT DÃ‰BUT!
  â†’ Les fondations sont solides
  â†’ La route vers le niveau 5 est tracÃ©e

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
